Super Dragon's Lair Arcade
==========================

Source code for the Super Nintendo retheme of RoadBlaster into Dragon's Lair. The game builds a fully playable SNES ROM targeting real NTSC hardware with MSU-1 audio/video on SD2SNES/FXPAK Pro.

Current snapshot
----------------
- Engine and build scripts are intact from RoadBlaster and produce a working ROM.
- Dragon's Lair chapter XMLs live in `./data/events` and drive chapter scripts in `./src/data/chapters`.
- Background audits and sprite prompt notes are documented in `./data/backgrounds/README.md` and `./data/sprites/README.md`.
- MSU-1 PCM/video assets are not bundled; supply your own Dragon's Lair audio and video captures when packaging chapters.

Requirements to build the game ROM
----------------------------------
- OS: Linux is the primary target; WSL works on Windows.
- Tools:
  - WLA DX 9.5a available in the folder `wla-dx-9.5-svn`.
  - Python 2.7.2 (not tested with Python 3+; tools may need adjustments).
  - `snesbrr` by DMV27 available in the tools folder `snesbrr-2006-12-13`.

Quick build steps
-----------------
1. Download, compile, and install WLA DX 9.5a by Ville Helin (http://www.villehelin.com/wla.html).
2. Download, compile, and install `snesbrr` by DMV27 (http://www.romhacking.net/utilities/407/).
3. Install Python 2.7.2. Other versions might work but may require modifications to tools.
4. Unpack Super Dragon's Lair Arcade source code.
5. Enter the source folder and run `make` to build the ROM.
6. Download the regular Super Dragon's Lair Arcade release and manually copy the manifest XML, MSU data file, and PCM sound files into the `./build` folder.
7. Run the game with an emulator, preferably bsnes v070.

MSU-1 asset packaging
---------------------
This release enables you to build the game ROM file but does not build MSU data files by default. The tooling exists to generate MSU video/audio, but it has been disabled because it requires the original video file from the iPhone version of the game and conversion is slow. If you provide Dragon's Lair captures, re-enable the MSU packaging steps and follow the prompts in `tools/xmlsceneparser.py`, `tools/gracon.py`, `tools/animationWriter.py`, and `tools/msu1blockwriter.py`.

General concept
---------------
This game is written purely in 65816 assembler. It uses an abstraction layer inspired by object-oriented programming to enhance flexibility. Resources such as work RAM, video RAM, color palettes, DMA channels, and more are allocated dynamically to optimize usage. The abstraction layer introduces a performance cost and is limited by WLA DX's capabilities.

Advantages of representing game systems as objects
--------------------------------------------------
- Generate any number of object instances without micro-managing data access. Multiple control scripts can run simultaneously.
- Group and process objects with shared interfaces. For example, objects implementing the dimension interface can be sorted by z-position for proper visual priority, while score objects can be sorted similarly for high-score lists.
- Tag properties (for example, `isDash`) allow related objects to move or update in unison without exposing implementation details.

Terminology
-----------
- **class**: Defined with the `CLASS` macro, which names methods and public members. Every class has default methods (`init`, `play`, `kill`).
- **object**: Instantiation of a class. Created with the `NEW` macro, which passes optional parameters to the constructor (`init`) and returns an object hash. Objects persist until explicitly killed; methods are called with the `CALL` macro.
- **object stack**: List of currently active objects (not a true stack).
- **object hash**: Unique reference pointing to an object in the object stack; auto-adjusts if the object moves.
- **object zp**: Private zero-page memory for an object instance, referenced with the `this.` prefix inside object code.
- **object properties**: Bitflags used to select and group objects (for example, all objects implementing the dimension interface expose position data).
- **abstract**: Classes that cannot be instantiated but provide methods to nearby objects. For example, `abstract.Sprite.65816` allocates memory and starts sprite animations.
- **garbage collection**: No implicit GC; objects are kept alive until explicitly killed. Killed objects are marked deleted and removed after the current frame finishes.
- **script**: An object type that controls game flow (for example, each video chapter, high-score screen, and title screen).
- **iterator**: Mechanism for iterating over sets of objects by class IDs or properties; each implementing object maintains iterator state.
- **unit tests**: A small set of unit tests checks core engine behavior.

Source folder structure
-----------------------
- **data**
  - `sounds`: Sound effect samples in WAV format; converted to BRR samples.
  - `songs`: Music in ProTracker MOD format with hardware-driven limitations (sample length/loop points divisible by 16, max size ~50 KB).
  - `sprites`: Sprite graphics (usually PNG); each file represents a frame in the resulting animation.
  - `font`: Font graphics files.
  - `backgrounds`: Background graphics files converted into background animation files.
  - `events`: XML files containing timing and action information for gameplay. These are used to cut up the original video file into chapters and generate script files in `./data/chapters`.
- **src**
  - `config`: Global static definitions, macros, and shared includes.
  - `core`: Core functionality such as booting, IRQ handling, and dynamic memory allocation for WRAM, VRAM, CGRAM, and DMA channels.
  - `definition`: Aliases for SNES and MSU-1 registers.
  - `object`: Classes that handle individual parts of the game (background layer types, HDMA effects, MSU1 interface, audio interface, etc.).
  - `text`: Text variables used throughout the game.
  - `*.script`: Top-level control scripts.
- **tools**
  - `animationWriter.py`: Uses `gracon.py` to write graphics animation files (sprite or backgrounds).
  - `gracon.py`: Converts graphics to various SNES formats; can optimize tiles and palettes.
  - `mod2snes.py`: Converts ProTracker MOD files to custom SNES format.
  - `msu1blockwriter.py`: Creates the MSU1 data file from chapter frames and audio.
  - `msu1pcmwriter.py`: Converts WAV audio to MSU1 PCM with headers.
  - `userOptions.py`: Helper for user input handling.
  - `xmlsceneparser.py`: Parses event XML files and generates chapter scripts and optional frame/audio extraction.

Initial program flow
--------------------
- Code in `./src/core/boot.65816` initializes core modules, instantiates `./src/main.script`, and enters the main loop.
- `./src/main.script` instantiates a copy of the MSU-1 interface and initializes high-score data (from battery-backed SRAM if applicable).
- Control passes to `./src/msu1.script`, which instantiates audio interfaces, displays the MSU-1 splash, and transitions to `./src/logo_intro.script` for the title sequence.
- Subsequent gameplay is controlled by events in chapter scripts located in `./src/data/chapters/`, generated from XML files in `./src/data/events/`.

Next steps
----------
- Replace remaining RoadBlaster background captures identified in `./data/backgrounds/README.md` with Dragon's Lair artwork.
- Package Dragon's Lair PCM audio and MSU video frames, then re-enable MSU-1 build steps for chapter bundles.
- Implement and test any missing event object handlers referenced by the curated XMLs to ensure all chapters play correctly.
