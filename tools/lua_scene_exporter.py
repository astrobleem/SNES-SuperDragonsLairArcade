#!/usr/bin/env python3
"""Export DirkSimple Lua scenes to legacy chapter.script format.

This tool reads the DirkSimple `tools/game.lua` scene table and emits a
`chapter.script` file per scene that mirrors the legacy layout generated by
``xmlsceneparser.py``. It keeps frame calculations relative to the first frame
in each scene and threads timeout/action transitions into the ``EventResult``
fields expected by the engine.
"""

from __future__ import annotations

import argparse
import logging
import pathlib
import re
from dataclasses import dataclass
from typing import Dict, Iterable, List, Tuple, Union


Number = Union[int, float]
LuaValue = Union["LuaTable", str, Number, None, bool]


FRAME_RATE_DEFAULT = 23.9777


def strip_comments(source: str) -> str:
    """Remove Lua ``--`` line comments."""

    return re.sub(r"--.*", "", source)


@dataclass
class Token:
    kind: str
    value: str


class LuaLexer:
    """Very small tokenizer for the Lua subset used in scenes tables."""

    TOKEN_REGEX = re.compile(
        r"(?P<whitespace>\s+)"  # spaces/newlines
        r"|(?P<number>\d+\.\d+|\d+)"  # integers/floats
        r"|(?P<string>\"[^\"]*\")"  # double-quoted strings (no escapes needed here)
        r"|(?P<identifier>[A-Za-z_][A-Za-z0-9_]*)"
        r"|(?P<brace>[{}])"
        r"|(?P<symbol>[=,+\-()])"
        r"|(?P<comma>,)"
    )

    def __init__(self, source: str) -> None:
        self.tokens: List[Token] = []
        for match in self.TOKEN_REGEX.finditer(source):
            kind = match.lastgroup
            if kind == "whitespace":
                continue
            self.tokens.append(Token(kind=kind or "", value=match.group(0)))
        self.position = 0

    def peek(self) -> Token | None:
        try:
            return self.tokens[self.position]
        except IndexError:
            return None

    def pop(self) -> Token:
        token = self.peek()
        if token is None:
            raise ValueError("Unexpected end of input while parsing Lua table")
        self.position += 1
        return token

    def expect(self, value: str) -> None:
        token = self.pop()
        if token.value != value:
            raise ValueError(f"Expected '{value}' but found '{token.value}'")


class LuaTable:
    def __init__(self, values: List[LuaValue], fields: Dict[str, LuaValue]):
        self.values = values
        self.fields = fields

    def as_python(self) -> Union[List[LuaValue], Dict[str, LuaValue]]:
        if self.fields and self.values:
            # Not expected in scene data; keep keyed preference for clarity.
            merged: Dict[str, LuaValue] = {str(i + 1): v for i, v in enumerate(self.values)}
            merged.update(self.fields)
            return merged
        if self.fields:
            return self.fields
        return self.values


class LuaParser:
    """Parse a very small subset of Lua expressions used in scene tables."""

    def __init__(self, source: str):
        self.lexer = LuaLexer(source)

    def parse_table(self) -> Union[List[LuaValue], Dict[str, LuaValue]]:
        self.lexer.expect("{")
        values: List[LuaValue] = []
        fields: Dict[str, LuaValue] = {}

        while True:
            token = self.lexer.peek()
            if token is None:
                raise ValueError("Unterminated Lua table")
            if token.value == "}":
                self.lexer.pop()
                break

            key: str | None = None
            if token.kind in {"identifier", "string"}:
                # Look ahead for key/value assignment.
                next_token = self.lexer.tokens[self.lexer.position + 1]
                if next_token.value == "=":
                    key = self._parse_key()
                    self.lexer.expect("=")

            value = self._parse_expression()
            if key is None:
                values.append(value)
            else:
                fields[key] = value

            token = self.lexer.peek()
            if token is not None and token.value == ",":
                self.lexer.pop()
                continue
            if token is not None and token.value == "}":
                continue
            if token is None:
                raise ValueError("Unterminated Lua table")

        return LuaTable(values, fields).as_python()

    def _parse_key(self) -> str:
        token = self.lexer.pop()
        if token.kind == "string":
            return token.value.strip('"')
        return token.value

    def _parse_expression(self) -> LuaValue:
        value = self._parse_term()
        while True:
            token = self.lexer.peek()
            if token is None or token.value not in {"+", "-"}:
                break
            op = self.lexer.pop().value
            rhs = self._parse_term()
            if isinstance(value, (int, float)) and isinstance(rhs, (int, float)):
                value = value + rhs if op == "+" else value - rhs
            else:
                raise ValueError(f"Unsupported arithmetic on non-numeric values: {value!r} {op} {rhs!r}")
        return value

    def _parse_term(self) -> LuaValue:
        token = self.lexer.pop()
        if token.value == "{":
            # Put the brace back for table parsing.
            self.lexer.position -= 1
            return self.parse_table()
        if token.kind == "string":
            return token.value.strip('"')
        if token.kind == "number":
            return float(token.value) if "." in token.value else int(token.value)
        if token.value == "true":
            return True
        if token.value == "false":
            return False
        if token.value == "nil":
            return None
        if token.kind == "identifier" and self._is_function_call():
            return self._parse_function_call(token.value)
        return token.value

    def _is_function_call(self) -> bool:
        next_token = self.lexer.peek()
        return next_token is not None and next_token.value == "("

    def _parse_function_call(self, name: str) -> Number:
        self.lexer.expect("(")
        args: List[LuaValue] = []
        while True:
            token = self.lexer.peek()
            if token is None:
                raise ValueError(f"Unterminated function call {name}(")
            if token.value == ")":
                self.lexer.pop()
                break
            args.append(self._parse_expression())
            token = self.lexer.peek()
            if token is not None and token.value == ",":
                self.lexer.pop()
                continue
            if token is not None and token.value == ")":
                continue
            raise ValueError(f"Unexpected token in function call {name}: {token.value}")

        return evaluate_function(name, args)


def evaluate_function(name: str, args: Iterable[LuaValue]) -> Number:
    """Evaluate known helper functions from game.lua."""

    if name == "time_to_ms":
        seconds, milliseconds = list(args)
        return int(seconds) * 1000 + int(milliseconds)
    if name == "laserdisc_frame_to_ms":
        (frame,) = args
        return (float(frame) / 23.976) * 1000.0
    if name == "time_laserdisc_frame":
        (frame,) = args
        return evaluate_function("laserdisc_frame_to_ms", [frame]) - 6297.0
    if name == "time_laserdisc_noseek":
        return -1
    raise ValueError(f"Unsupported function call {name}() in scene table")


def load_scene_table(lua_path: pathlib.Path) -> Dict[str, Dict[str, dict]]:
    source = lua_path.read_text(encoding="utf-8")
    stripped = strip_comments(source)
    match = re.search(r"scenes\s*=\s*{", stripped)
    if not match:
        raise ValueError("Unable to locate scenes table in Lua file")
    table_source = stripped[match.start() + stripped[match.start():].find("{") :]
    parser = LuaParser(table_source)
    parsed = parser.parse_table()
    if not isinstance(parsed, dict):
        raise ValueError("Scene table did not parse into a dictionary")
    return parsed  # type: ignore[return-value]


def ms_to_frame(time_ms: Number, fps: float) -> int:
    return int(float(time_ms) * (fps * 0.001))


def sanitize(name: str) -> str:
    return re.sub(r"[^A-Za-z0-9_]", "_", name)


@dataclass
class ScriptEvent:
    type: str
    frame_start: int
    frame_end: int
    result: str = "none"
    result_name: str = "none"
    arg0: Union[str, int] = ""
    arg1: Union[str, int] = ""
    arg2: Union[str, int] = ""

    def to_line(self) -> str:
        return (
            f"    EVENT Event.{self.type}.CLS.PTR $" \
            f"{self.frame_start:04x} ${self.frame_end:04x} "
            f"EventResult.{self.result} {self.result_name} {self.arg0} {self.arg1} {self.arg2}\n\n"
        )


def build_events(scene_name: str, sequences: Dict[str, dict], fps: float) -> List[ScriptEvent]:
    """Create ScriptEvent entries from a parsed scene."""

    chapter_start = min(
        [seq.get("start_time", 0) for seq in sequences.values()]
    ) if sequences else 0
    chapter_end = max(
        [seq.get("start_time", 0) + _timeout_duration(seq) for seq in sequences.values()]
    ) if sequences else 0

    events: List[ScriptEvent] = [
        ScriptEvent(
            type="chapter",
            frame_start=max(0, ms_to_frame(chapter_start, fps)),
            frame_end=max(0, ms_to_frame(chapter_end, fps)),
            result="none",
            result_name="none",
            arg0=scene_name,
            arg1="",
            arg2="",
        )
    ]

    for sequence_name, sequence in sequences.items():
        events.extend(_events_for_sequence(scene_name, sequence_name, sequence, chapter_start, fps))

    return sorted(events, key=lambda evt: (evt.frame_start, evt.frame_end))


def _timeout_duration(sequence: dict) -> Number:
    timeout = sequence.get("timeout", {})
    return timeout.get("when", 0) if isinstance(timeout, dict) else 0


def _events_for_sequence(
    scene_name: str,
    sequence_name: str,
    sequence: dict,
    chapter_start_ms: Number,
    fps: float,
) -> List[ScriptEvent]:
    start_ms = sequence.get("start_time", 0)
    timeout = sequence.get("timeout", {}) or {}
    duration_ms = timeout.get("when", 0)
    end_ms = start_ms + duration_ms

    result, result_name = _sequence_result(scene_name, sequence, timeout)

    events = [
        ScriptEvent(
            type=sanitize(sequence_name),
            frame_start=max(0, ms_to_frame(start_ms - chapter_start_ms, fps)),
            frame_end=max(0, ms_to_frame(end_ms - chapter_start_ms, fps)),
            result=result,
            result_name=sanitize(result_name),
            arg0=int(sequence.get("points", 0)) if sequence.get("points") is not None else "",
            arg1="",
            arg2="",
        )
    ]

    actions = sequence.get("actions", []) or []
    for action in actions:
        events.append(_event_for_action(scene_name, sequence_name, action, start_ms, chapter_start_ms, fps))

    return events


def _sequence_result(scene_name: str, sequence: dict, timeout: dict) -> Tuple[str, str]:
    if sequence.get("kills_player"):
        return "restartchapter", scene_name
    target = timeout.get("nextsequence")
    if isinstance(target, str):
        return "playchapter", f"{scene_name}.{target}"
    return "none", "none"


def _event_for_action(
    scene_name: str,
    sequence_name: str,
    action: dict,
    sequence_start_ms: Number,
    chapter_start_ms: Number,
    fps: float,
) -> ScriptEvent:
    start_ms = sequence_start_ms + action.get("from", 0)
    end_ms = sequence_start_ms + action.get("to", action.get("from", 0))
    target = action.get("nextsequence")
    result = "playchapter" if isinstance(target, str) else "none"
    result_name = f"{scene_name}.{target}" if isinstance(target, str) else action.get("interrupt", "none")

    return ScriptEvent(
        type=sanitize(f"{sequence_name}_{action.get('input', 'action')}"),
        frame_start=max(0, ms_to_frame(start_ms - chapter_start_ms, fps)),
        frame_end=max(0, ms_to_frame(end_ms - chapter_start_ms, fps)),
        result=result,
        result_name=sanitize(str(result_name)),
        arg0=action.get("points", ""),
        arg1=action.get("input", ""),
        arg2=action.get("nextsequence", ""),
    )


def write_chapter_script(output_dir: pathlib.Path, scene_name: str, events: List[ScriptEvent]) -> None:
    chapter_dir = output_dir / sanitize(scene_name)
    chapter_dir.mkdir(parents=True, exist_ok=True)
    script_path = chapter_dir / "chapter.script"

    with script_path.open("w", encoding="utf-8") as script_file:
        script_file.write("/**\n* this file has been auto-generated.\n*/\n\n")
        script_file.write(f"    CHAPTER {sanitize(scene_name)}\n\n")
        for event in events:
            script_file.write(event.to_line())
        script_file.write("    DIE\n")


def export_scenes(lua_path: pathlib.Path, output_dir: pathlib.Path, filter_set: set[str] | None, fps: float) -> None:
    scenes = load_scene_table(lua_path)
    selection = {name: scenes[name] for name in scenes if filter_set is None or name in filter_set}

    if not selection:
        raise ValueError("No scenes matched the provided filter")

    for scene_name, sequences in selection.items():
        logging.info("Exporting scene '%s'", scene_name)
        events = build_events(scene_name, sequences, fps)
        write_chapter_script(output_dir, scene_name, events)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "-i",
        "--input",
        dest="input_path",
        default=pathlib.Path("tools/game.lua"),
        type=pathlib.Path,
        help="Path to DirkSimple game.lua file containing the scenes table.",
    )
    parser.add_argument(
        "-o",
        "--output",
        dest="output_dir",
        default=pathlib.Path("./data/chapters"),
        type=pathlib.Path,
        help="Directory where chapter folders and chapter.script files are written.",
    )
    parser.add_argument(
        "-c",
        "--chapter",
        dest="chapters",
        action="append",
        help="Optional scene name to export; repeat for multiple names.",
    )
    parser.add_argument(
        "--fps",
        dest="fps",
        type=float,
        default=FRAME_RATE_DEFAULT,
        help="Frames-per-second to use when converting milliseconds to frames.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable debug logging while parsing and exporting.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO, format="%(message)s")
    export_scenes(args.input_path, args.output_dir, set(args.chapters) if args.chapters else None, args.fps)


if __name__ == "__main__":
    main()
